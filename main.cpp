/* -LICENSE-START-
** Copyright (c) 2018 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

// Modified 2019 S.Fuchita (@soramimi_jp)


#include <stdio.h>
#include <thread>
#include <chrono>
#include <mutex>
#include <condition_variable>
#include "platform.h"
#include "DeckLinkAPI.h"
#include "MainWindow.h"
#include <QApplication>
#include <QDebug>
#include <QPainter>


class DeckLinkMonitor {
private:
	std::mutex playbackMutex_;
	std::condition_variable playbackStopCondition_;
	bool interrupted_ = false;
	bool running = false;
public:

	void PlaybackStills(IDeckLinkOutput *decklink_output, IDeckLinkVideoFrame *playback_frame, long update_interval_ms)
	{
		std::chrono::milliseconds timer_period(update_interval_ms);
		unsigned int frame_count = 0;

		while (1) {
			{
				int frame_w = playback_frame->GetWidth();
				int frame_h = playback_frame->GetHeight();
				QImage image(frame_w, frame_h, QImage::Format_RGB32);
				if (frame_count & 1) {
					image.fill(Qt::blue);
				} else {
					image.fill(Qt::black);
				}
				if (1) {
					if (1) {
						QImage img;
//						img.load("/home/soramimi/a/example.png");
						img.load("../lena_std.png");
						int img_w = img.width();
						int img_h = img.height();
						int x = (frame_w - img_w) / 2;
						int y = (frame_h - img_h) / 2;
						QPainter pr(&image);
						pr.drawImage(x, y, img);
					}
					uint8_t *bits = nullptr;
					if (playback_frame->GetBytes((void**)&bits) == S_OK && bits) {
						int stride = playback_frame->GetRowBytes();
						for (int y = 0; y < frame_h; y++) {
							uint8_t *dst = bits + stride * y;
							uint8_t *src = image.scanLine(y);
							for (int x = 0; x < frame_w; x++) {
								memcpy(dst, src, frame_w * 4);
							}
						}
					}
				}
			}

			{
				HRESULT result = decklink_output->DisplayVideoFrameSync(playback_frame);
				if (result != S_OK) {
					qDebug() << "Unable to display video output\n";
					break;
				}
			}
			frame_count++;

			std::unique_lock<std::mutex> lock(playbackMutex_);
			if (playbackStopCondition_.wait_for(lock, timer_period, [&]{ return interrupted_; })) {
				qDebug() << "interrupted";
				break;
			}
		}
	}

	std::thread playbackStillsThread;
	IDeckLinkMutableVideoFrame *playbackFrame = nullptr;
	IDeckLinkOutput *selectedDeckLinkOutput = nullptr;
	IDeckLinkIterator *deckLinkIterator = nullptr;
	BMDTimeValue frameDuration = 1001;
	BMDTimeValue frameTimescale = 30000;
	bool loopPlayback = false;
	int exitStatus = 1;

	struct DisplayMode {
		IDeckLinkDisplayMode *mode;
		std::string name;
		DisplayMode() = default;
		DisplayMode(IDeckLinkDisplayMode *mode, std::string const &name)
			: mode(mode)
			, name(name)
		{
		}
	};

	std::vector<DisplayMode> dispmodes;

public:
	DeckLinkMonitor() = default;
	~DeckLinkMonitor()
	{
		stop();
	}

	bool start()
	{
		exitStatus = 1;

		// Configuration flags
		bool err = false;

		const int deckLinkIndex = 0;
		const int displayModeIndex = 8;

		BMDDisplayMode selectedDisplayMode = bmdModeNTSC;
		std::string selectedDisplayModeName;

		std::vector<std::string> deckLinkDeviceNames;

		deckLinkIterator = nullptr;
		{
			HRESULT result = GetDeckLinkIterator(&deckLinkIterator);
			if (result != S_OK) return false;
		}

		if (deckLinkIndex < 0) {
			fprintf(stderr, "You must select a device\n");
			err = true;
		}

		// Obtain the required DeckLink device

		selectedDeckLinkOutput = nullptr;
		{
			int index = 0;
			while (1) {
				IDeckLink *decklink = nullptr;
				HRESULT r = deckLinkIterator->Next(&decklink);
				if (r != S_OK) break;

				QString devicename;

				{
#ifdef Q_OS_WIN
					DLString name;
					r = decklink->GetDisplayName(&name);
					if (r == S_OK) {
						devicename = name;
						deckLinkDeviceNames.push_back(devicename.toStdString());
					}
#else
					dlstring_t name;
					r = decklink->GetDisplayName(&name);
					if (r == S_OK) {
						devicename = name;
						deckLinkDeviceNames.push_back(DlToStdString(name));
						DeleteString(name);
					}
#endif
				}

				if (index == deckLinkIndex) {
					// Check that selected device supports playback
					int64_t ioSupportAttribute = 0;
					{
						IDeckLinkProfileAttributes *atts = nullptr;
						r = decklink->QueryInterface(IID_IDeckLinkProfileAttributes, (void **)&atts);
						if (r != S_OK) {
							fprintf(stderr, "Unable to get IDeckLinkAttributes interface\n");
							return false;
						}

						if (atts->GetInt(BMDDeckLinkVideoIOSupport, &ioSupportAttribute) != S_OK) {
							ioSupportAttribute = 0;
						}

						atts->Release();
					}

					if (ioSupportAttribute & bmdDeviceSupportsPlayback) {
						r = decklink->QueryInterface(IID_IDeckLinkOutput, (void **)&selectedDeckLinkOutput);
						if (r != S_OK) {
							fprintf(stderr, "Unable to get IDeckLinkOutput interface\n");
							return false;
						}
					} else {
						fprintf(stderr, "Selected device does not support playback\n");
						err = true;
					}
				}
				index++;

				decklink->Release();
			}
		}

		// Get display modes from the selected decklink output
		if (selectedDeckLinkOutput) {
			{
				IDeckLinkDisplayModeIterator *displayModeIterator = nullptr;
				HRESULT result = selectedDeckLinkOutput->GetDisplayModeIterator(&displayModeIterator);
				if (result != S_OK) {
					fprintf(stderr, "Unable to get IDeckLinkDisplayModeIterator interface\n");
					return false;
				}
				{
					IDeckLinkDisplayMode *displayMode = nullptr;
					while (displayModeIterator->Next(&displayMode) == S_OK) {
#ifdef Q_OS_WIN
						DLString displayModeName;
						HRESULT result = displayMode->GetName(&displayModeName);
						std::string name;
						if (result == S_OK) {
							name = displayModeName;
						}
						dispmodes.emplace_back(displayMode, name);
#else
						dlstring_t displayModeName;
						HRESULT result = displayMode->GetName(&displayModeName);
						std::string name;
						if (result == S_OK) {
							name = DlToStdString(displayModeName);
							DeleteString(displayModeName);
						}
						dispmodes.emplace_back(displayMode, name);
#endif
					}
				}
				displayModeIterator->Release();
			}

			if (displayModeIndex < 0 || displayModeIndex > (int)dispmodes.size()) {
				fprintf(stderr, "You must select a valid display mode\n");
				err = true;
			} else {
				selectedDisplayMode = dispmodes[displayModeIndex].mode->GetDisplayMode();
				selectedDisplayModeName = dispmodes[displayModeIndex].name;

				{
					HRESULT result = dispmodes[displayModeIndex].mode->GetFrameRate(&frameDuration, &frameTimescale);
					if (result != S_OK) return false;
				}

				// Check display mode is supported with given options
				// Passing pixel format = 0 to represent any pixel format
#ifdef Q_OS_WIN
				BOOL dispmodesupported;
#else
				dlbool_t dispmodesupported;
#endif
				HRESULT result = selectedDeckLinkOutput->DoesSupportVideoMode(bmdVideoConnectionUnspecified, selectedDisplayMode, bmdFormatUnspecified, bmdSupportedVideoModeDefault, nullptr, &dispmodesupported);
				if (result != S_OK || !dispmodesupported) {
					fprintf(stderr, "The display mode %s is not supported by device\n", selectedDisplayModeName.c_str());
					err = true;
				}
			}

		}

		if (err) {
			return false;
		}

		// Set the video output mode
		{
			HRESULT result = selectedDeckLinkOutput->EnableVideoOutput(selectedDisplayMode, bmdVideoOutputFlagDefault);
			if (result != S_OK) {
				fprintf(stderr, "Unable to enable video output\n");
				return false;
			}
		}

		// Create video frame for playback, as we are outputting frame synchronously,
		// then we can reuse without waiting on callback
		{
			IDeckLinkDisplayMode *mode = dispmodes[displayModeIndex].mode;
			HRESULT result = selectedDeckLinkOutput->CreateVideoFrame((int32_t)mode->GetWidth(),
																	  (int32_t)mode->GetHeight(),
																	  (int32_t)mode->GetWidth() * 4,
																	  bmdFormat8BitBGRA,
																	  bmdFrameFlagDefault,
																	  &playbackFrame);
			if (result != S_OK) {
				fprintf(stderr, "Unable to create video frame\n");
				return false;
			}
		}

		// OK to start playback - print configuration
		fprintf(stderr, "Output with the following configuration:\n"
						" - Playback device: %s\n"
						" - Video mode: %s\n"
				,
				deckLinkDeviceNames[deckLinkIndex].c_str(),
				selectedDisplayModeName.c_str()
				);

		// Start thread for message processing
		playbackStillsThread = std::thread([&]{
			running = true;
			int interval_ms = 500;
			PlaybackStills(selectedDeckLinkOutput, (IDeckLinkVideoFrame *)playbackFrame, interval_ms);
		});

		exitStatus = 0;
		return true;
	}
	void stop()
	{
		if (running && !interrupted_) {
			{
				std::lock_guard<std::mutex> lock(playbackMutex_);
				interrupted_ = true;
				playbackStopCondition_.notify_all();
			}
			playbackStillsThread.join();
		}

		for (DisplayMode &dm : dispmodes) {
			dm.mode->Release();
		}
		dispmodes.clear();

		if (playbackFrame) {
			playbackFrame->Release();
			playbackFrame = nullptr;
		}

		if (selectedDeckLinkOutput) {
			selectedDeckLinkOutput->DisableVideoOutput();
			selectedDeckLinkOutput->Release();
			selectedDeckLinkOutput = nullptr;
		}

		if (deckLinkIterator) {
			deckLinkIterator->Release();
			deckLinkIterator = nullptr;
		}
	}

};

int main(int argc, char *argv[])
{
#ifdef Q_OS_WIN
	CoInitialize(nullptr);
#endif

	QApplication a(argc, argv);
	MainWindow w;
	w.show();

	DeckLinkMonitor dlm;
	dlm.start();

	int r = a.exec();

	dlm.stop();

#ifdef Q_OS_WIN
	CoUninitialize();
#endif

	return r;
}
